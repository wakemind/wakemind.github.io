# 变量重复声明

## 1 前言

JS 的「容错率很高」，一些其他
语言常见的小错误 JS 都能大度得包容，比如给一个方法传入超出预计的参数、在声明变量之前使用该变量（变量的声明提升解决了这个问题）等等

【要点】
 
 * ```函数声明```是函数的声明和实现都被提升了
    > 解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）
 
 * ```函数表达式和变量表达式```只是其声明被提升了
    > 必须等到解析器执行到它所在的代码行，才会真正被解释执行 
 
 * ```函数体内```，局部变量的优先级高于全局变量
 
 
## 2 变量重复声明

这里我们就要解剖一下 JS 变量重复声明以及当我们忽略 var 使用 a=2 来声明变量时 a 为全局变量的问题：

```
//【第一段代码】  
var a = 2;  
var a = 3;  
//3  
alert(a);

//【第二段代码】
a = 2;  
// 2
alert(a);
```

- 第一段代码：

    JS 会「默默忽略掉」第二个 var 声明来将程序继续执行下去，而且后面声明的值会覆盖掉前面声明的值
- 第二段代码

    JS 会「将忽略 var 的声明默认声明为全局变量」
    
## 3 变量名与函数名重名

```
// a()
console.log(a);

var a=100;
var b = 1;
function a(){
　　console.log(a);
　　
　　// 1
　　console.log(b);
　　b = 2;
}

// 100
console.log(a);
//a is not a function
a(); 
```

## 4 使用 let 

使用 let 语句，允许你在 JavaScript 中创建```块范围局部变量```。let 语句是在 JavaScript 的 ECMAScript 6 标准中引入的。

- **let 声明的变量没有变量提升**

    使用 let 声明的变量提升不同于使用 var 声明的变量。因此，使用 let 声明的变量没有变量提升，这意味着使用 let 声明的变量不会移动到执行上下文的顶部

    ```
    // ame is not defined
    console.log(name);
    	
    let name = "bob";
    	
    // bob
    console.log(name);
    	
    ```

- **let 不能重新声明一个变量**
你不能在同一个函数或块中使用 let 重新声明一个变量。这样做会出现```语法错误```

    ```
    function foo() {
        if(true){
            let x = 9;
            let x = 89;
        }
    }
    foo();
    ```
## 【参考资料】
- 《JavaScript高级程序设计》第7.3章节，原话如下：
    
    > JavaScript 从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，它会执行后续声明中的变量初始化）。匿名函数可以用来模仿块级作用域并避免这个问题。


