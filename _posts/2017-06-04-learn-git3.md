---
layout: post
title:  "Learn Git. Git Branching. Codecademy на русском"
date:   2017-06-04 21:08
category: codecademy
icon: git
keywords: codecademy, перевод, курс, git
image: 2.png
preview: 0
---

<h2>Содержание:</h2>
<ol>
	<li><a href="#bran1">Git Branch</a></li>
	<li><a href="#over">Branching Overview</a></li>
	<li><a href="#bran2">Git Branch 2</a></li>
	<li><a href="#chec">Git Checkout</a></li>
	<li><a href="#nbran">Commit on a new branch</a></li>
	<li><a href="#mer">Git merge</a></li>
	<li><a href="#mer1">Merge conflict I</a></li>
	<li><a href="#mer2">Merge conflict II</a></li>
	<li><a href="#del">Delete Branch</a></li>
	<li><a href="#res">Итоги</a></li>
</ol>

<h2 id="bran1">Git Branch</h2>
<p>До этого момента Вы работали в единственной Git-ветке, которая называлась <code>master</code>. Git позволяет нам создавать <i>ветки</i>, как эксперимент в версией проекта. Представьте, что вы хотите создать версию истории со счастливым концом. Вы можете создать новую ветку со счастливым концом, и все изменения находятся только в ветке. Она никак не влияет на <code>master</code> до тех пор, пока вы не захотите слияния счастливого конца с веткой master.</p>
<p>В этом уроке мы будем использовать ветвление, чтобы разработать несколько версий резюме.</p>
<p>Вы можете использовать эту команду, чтобы найти ответ на вопрос: "На какой сейчас я ветке?": <code>git branch</code></p>
<h3>Инструкции:</h3>
<ol>
	<li>Проверьте на какой ветке Вы сейчас находитесь. В выходных данных <code>*</code> (звёздочка) показывает, на какой ветке ты сейчас. Сейчас проект использует только одну ветку.<br>Нажмите Next, чтобы сделать новую ветку.</li>
</ol>
<h2 id="over">Branching Overview</h2>
<p>Диаграмма справа иллюстрирует ветвление.
	<ul>
		<li>Кружки - это коммиты, и вместе они формирует историю Git-проекта.</li>
		<li><i>Новая ветка</i> - это другая <i>версия</i> Git-проекта. Он включает в себя и коммиты из <i>Master</i>, но и также коммиты, которые <i>Master</i> не имеет.</li>
	</ul>
</p>
Нажмите Next чтобы сделать свою первую ветку.
</p>
<h2 id="bran2">Git Branch 2</h2>
<p>Прямо сейчас Git-проект имеет только одну ветку: <code>master</code>.</p>
<p>Чтобы создать новую ветку, используйте команду <code>git branch new_branch</code></p>
<p>Здесь <code>new_branch</code> означает имя новой ветки, которую вы хотите сделать, как <code>photos</code> или <code>blurb</code>. Убедитесь, что название вашей ветки описывает цель вашей ветки. А также то, что имя ветки не должно содержать пробелов: <code>new-branch</code> и <code>new_branch</code> - это правильные имена веток, а вот <code>new branch</code> - нет.</p>
<h3>Инструкции:</h3>
<ol>
	<li>Давайте сделаем новую версию нашего резюме для подачи на работу инструктором по фехтованием.<br>
	Назовите новую ветку <code>fencing</code>.<br>
	Затем посмотрите ветки с помощью той команды, которую изучали в прошлом занятии.<br>
	Заметьте, что в терминале выведется две ветки:<code>master</code> и <code>fencing</code>.</li>
</ol>
<h2 id="chec">Git Checkout</h2>
<p>Отлично! Вы создали новую ветку.</p>
<p>Сейчас <code>master</code> и <code>fencing</code> ветки индентичны: они имеют одинаковую коммит-историю. Вы можете переключиться на новую ветку с помощью команды <code>git checkout branch_name</code></p>
<p>Здесь <code>branch_name</code> это имя ветки. Если имя ветки было б <code>skill</code>, то команда выглядела бы так:<br><code>git checkout skill</code></p>
<p>Как только вы переключились на другую ветку, вы можете делать коммиты, которые не будут влиять на <code>master</code>.</p>
<p>Вы можете продолжать свой рабочий процесс, при этом <code>master</code> остается нетронутым!</p>
<h3>Инструкции:</h3>
<ol>
	<li>Переключитесь из <code>master</code> на ветку <code>fencing</code>.</li>
	<li>Используйте команду <code>git branch</code>, чтобы проверить на какую ветку вы переключились<br>
	Заметьте, в выводе <code>*</code> теперь находиться на <code>fencing</code> ветке</li>
</ol>
<h2 id="nbran">Commit on a new branch</h2>
<p>Наши поздравления! Вы переключились на новую ветку. Все команды, которые вы делали с <code>master</code>, вы также можете делать с этой веткой.</p>
<p>Например, чтобы индексировать файл, используем: <code>git add filename</code>, а чтобы закоммитить: <code>git commit -m "Commit message"</code></p>
<p>Сейчас мы сделаем коммит на <code>fencing</code> ветке. Справа, на схеме, показано, что будет с проектом после коммита.</p>
<h3>Инструкции:</h3>
<ol>
	<li>Посмотрите лог проекта<br>
	Обратите внимание на выходные данные:
	<ul>
		<li>Все коммиты, которые вы видите, сделаны в <code>master</code>. <code>fencing</code> унаследовал их.</li>
		<li>Это значит, что каждый коммит ветки <code>master</code> есть в <code>fencing</code></li>
	</ul><i>Примечание:</i> если курсор находиться в git log mode нажмите <code>q</code>, чтобы выйти.</li>
	<li>В <b>resume.txt</b> удалите строку <code>-Scheme against Captain Hook</code> и вставьте вместо неё: <code>-Engage in swordfights with pirates</code></li>
	<li>Проиндексируйте <b>resume.txt</b> </li>
	<li>Сделайте коммит изменения с сообщением в репозиторий.</li>
</ol>
<h2 id="mer">Git merge</h2>
<p>Что если мы хотим включить все изменения, сделанные в <code>fencing</code> в ветку <code>master</code>? Мы легко может это сдедать <i>слияние</i> этих веток: <code>git merge branch_name</code></p>
<p>Например, если мы хотим слить <code>skills</code> в master, я введу: <code>git merge skills</code></p>
<p>Сейчас мы сольём ветки. Имейте в виду:
<ul>
	<li>Ваша цель - это обновление <code>master</code> с изменениями, которые вы делали в ветке <code>fencing</code>.</li>
	<li><code>fencing</code> является отдающей веткой, посколько она обеспечивает изменения.</li>
	<li><code>master</code> является получающей веткой, поскольку она принимает изменения.</li>
</ul></p>
<h3>Инструкции:</h3>
<ol>
	<li>Сейчас вы на ветке <code>fencing</code>. Переключитесь на <code>master</code>.</li>
	<li>Через терминал слейте ветку <code>fencing</code> в <code>master</code>.<br>
	Обратите внимание на выходные данные: слияние - это "быстрая перемотка вперед", потому что Git знает, что <code>fencing</code> содержит самые недавние коммиты. Git перематывает вперед, чтобы сравнять с <code>fencing</code>.</li>
</ol>
<h2 id="mer1">Merge conflict I</h2>
<p>Слияние прошло успешно, потому что
<code>master</code> не изменилось с тех пор, как мы сделал коммит на <code>fencing</code>. Git знал, что просто обновил <code>master</code> с изменениями ветки <code>fencing</code>.</p>
<p>Что произойдет, если вы сделаете коммит в ветке <code>master</code> <i>перед</i> тем, как вы объединили две ветви? Кроме того, что если коммит, который вы сделаете на <code>master</code>, изменит тот же самый текст, с которым вы работали в <code>fencing</code>? Когда мы переключимся назад на ветку <code>master</code> и спросите git о слиянии двух веток, то Git не поймёт какое изменение он хочет сохранить. Это называется <i>конфликт слияния</i>.</p>
<h3>Инструкции:</h3>
<ol>
	<li>Сейчас вы на ветке <code>master</code>. В редакторе где написано <code>-Engage in swordfights with pirates</code> добавьте слово "professional" так, чтобы текст выглядил так: <code>-Engage in swordfights with professional pirates</code>. Нажмите Run.</li>
	<li>Проиндексируйте файл <b>resume.txt</b>.</li>
	<li>Сделайте коммит изменений в репозиторий с сообщением.</li>
	<li>Представте, что прошло несколько недель, и вы захотели снова продолжить развивать резюме по фехтованию. Вернитесь снова в ветку <code>fencing</code>.</li>
	<li>В ветке <code>fencing</code> поменяйте строку следующим образом: <code>-Engage in swordfights with professional pirates such as Smee.</code>. Нажмите Run.</li>
	<li>Теперь снова проиндексируйте файл <b>resume.txt</b>.</li>
	<li>Сделайте коммит изменений в репозиторий с сообщением.</li>
</ol>
<h2 id="mer2">Merge conflict II</h2>
<p>Скажем, вы решили слить из ветки <code>fencing</code> в <code>master</code>.</p>
<p>Вот тут и начинается проблемы!</p>
<p>Вы сделали коммиты на отдельных ветках, которые разделяет одну и ту же строку в разные стороны. Сейчас, когда мы попытаемя слить <code>fencing</code> в <code>master</code>, Git не сможет понять, какую версию ему сохранять.</p>
<h3>Инструкции:</h3>
<ol>
	<li>Переключитесь на ветку <code>master</code>.</li>
	<li>Через терминал введите команду: <code>git merge fencing</code><br>
	Это будет попытка слить <code>fencing</code> в <code>master</code>. В результате терминал нам вернёт:
	<code>CONFLICT (content): Merge conflict in resumé.txt
Automatic merge failed; fix conflicts and then commit the result.</code></li>
	<li>Мы должны решить конфликт.<br>
	Посмотрите файл <b>resume.txt</b> в редакторе. Git использовал маркировки <code>HEAD</code>(master) версия файла и <code>fencing</code> версию файла:[посмотрите третий пункт в инструкции]. Git как бы спрашивает нас, какую версию файла ему сохранить: <code>master</code>(master) версия <code>fencing</code> версию. Вы решили, что хотите сохранить <code>fencing</code> версию.<br>
	Через редактор:<br>
	удалите содержимое тех строк, которые выглядят как в ветке <code>master</code>.<br>
	Удалите <b>все специльные маркеры Git-а</b>, включая слова <code>HEAD</code> и <code>fencing</code>. Если какие-либо маркеры Git-а, как, например, >>>>>>> and =======, остаются, то конфликт сохраняется.<br>
	Попробуйте перезагрузить страницу, если Git-маркеры не появились.</li>
	<li>Проиндексируйте <b>resume.txt</b>.</li>
	<li>Теперь сделайте коммит. В качестве коммит-сообщения наберите "Resolve merge conflict" (разрешение конфликта слияния), для того, чтобы отметить цель данного коммита.</li>
</ol>

<h2 id="del">Delete Branch</h2>
<p>Обычно, в Git-е ветки подразумевают конечную цель. Вы сделали их для разработки новой особенности (фичи) проекта и как только цель достигнута, ветка сливается в <code>master</code>. После того, как ветка слилась в <code>master</code>, она достигла цель и может быть удалена.</p>
<p>Команда <code>git branch -d branch_name</code> удаляет выбранную ветку из Git-проекта.</p>
<p>Сейчас, <code>master</code> содержит все файловые изменения из <code>fencing</code>, давайте удалим <code>fencing</code>.</p>
<h3>Инструкции:</h3>
<ol>
	<li>Удалите ветку <code>fencing</code><br>
	Теперь проверьте, действительно ли <code>fencing</code> удалилась из списка веток нашего проекта.<br>
	Заметьте, что в результате выйдет только одна ветка, <code>master</code>. Нажмите Next, чтобы продолжить.</li>
</ol>
<h2 id="res">Итоги</h2>
<p>Давайте воспользуемся моментом, чтобы повторить основные понятия и команды из уроков, прежде чем двигаться дальше.</p>
<ul>
	<li><i>Ветвление</i> в git позволяет пользователям экспериментировать с разными версиями проекта, проверяя отдельные <i>ветки</i> на работу в проекте.</li>
</ul>
<p>Следующие команды полезны для работы с ветками:</p>
<ul>
	<li>git branch: список всех Git-веток.</li>
	<li>git branch branch_name: создаёт новую ветку.</li>
	<li>git checkout branch_name: используется для переключения с одной ветки на другую.</li>
	<li>git merge branch_name: используется для присоединения изменений файла с одной ветки в другую.</li>
	<li>git branch -d branch_name: удаляет указанную ветку.</li>
</ul>